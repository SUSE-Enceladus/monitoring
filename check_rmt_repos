#!/usr/bin/env python3

# Copyright (c) 2019 SUSE LLC  All rights reserved.
#
# check_rmt_repos is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, version 2 of
# the License.
#
# check_rmt_repos is distributed in the hope that it will
# be useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with check_rmt_repos. If not, see
# <http://www.gnu.org/licenses/>.
#

import argparse
import json
import os
import subprocess
import sys
import csv
from io import StringIO

# Nagios states
OK = 0
WARNING = 1
CRITICAL = 2
UNKNOWN = 3


def get_enabled_rmt_repos():
    repo_info_cmd = ['rmt-cli', 'repos', 'list', '--csv']
    proc = subprocess.Popen(repo_info_cmd, stdout=subprocess.PIPE)
    avail_repo_data, errors = proc.communicate()

    if errors:
        print('Error executing "rmt-cli repos list"')
        sys.exit(CRITICAL)

    rmt_repos = {}
    f = StringIO(avail_repo_data.decode())
    f.readline()  # skip table headers
    csv_reader = csv.reader(f, delimiter=',')
    for repo_detail in csv_reader:
        id = repo_detail[0].strip()
        name = repo_detail[1].strip()
        rmt_repos[id] = name

    return rmt_repos


def get_rmt_cli_command():
    rmt_cli_pid = get_rmt_cli_pid()
    rmt_cli_cmd = None
    if rmt_cli_pid:
        rmt_cli_cmd = open('/proc/%s/cmdline' % rmt_cli_pid, 'r').read()
        rmt_cli_cmd = rmt_cli_cmd.replace('\x00', ' ')
    return rmt_cli_cmd


def get_rmt_cli_pid():
    rmt_cli_pid_cmd = ['ps', '-C', 'rmt-cli', '-o', 'pid=']
    rmt_cli_pid = subprocess.Popen(rmt_cli_pid_cmd, stdout=subprocess.PIPE)
    pid_data = rmt_cli_pid.communicate()
    return pid_data[0].strip().decode()


def get_mirrored_repos():
    mirrored_repos = {}
    for root, dirs, files in os.walk('/var/lib/rmt/public/repo'):
        for dirname in dirs:
            if dirname == 'repodata':
                mirrored_repos[root] = True
    return mirrored_repos


# Set up command line argument parsing
argparse = argparse.ArgumentParser(description='Monitor repo setup for RMT')
argparse.add_argument(
    '-f', '--config-file',
    dest='config_file_path',
    default='/etc/rmt-utils/rmt_repository_config.json',
    help='Path to json config file for RMT repo configuration',
    metavar='CONFIG_FILE'
)
help_msg = 'A designator that will compare the repository configuration '
help_msg += '"framework" setting with the provided value'
argparse.add_argument(
    '--cloud',
    dest='framework',
    required=True,
    help=help_msg
)
args = argparse.parse_args()
enabled_repos = get_enabled_rmt_repos()
mirrored_repos = get_mirrored_repos()

if not os.path.exists(args.config_file_path):
    print('Missing "%s"' % args.config_file_path)
    sys.exit(CRITICAL)

rmt_cli_command = get_rmt_cli_command()
if rmt_cli_command and 'mirror' in rmt_cli_command:
    # While the mirror process is running we do not complain about
    # missing directories. They are expected to show up at the end
    # of the mirror process.
    sys.exit(OK)

configured_repo_ids = []
not_enabled = []
missing_repo_dirs = []
extra_enabled_repos = []
extra_mirrored_repos = []
with open(args.config_file_path) as json_file:
    config_repos = json.load(json_file)
    for config_repo in config_repos:
        for id, repo_info in config_repo.items():
            repo_framework = repo_info.get('framework')
            if repo_framework and repo_framework != args.framework:
                # Skip repos that are not configured for this framework
                continue
            configured_repo_ids.append(id)
            if not enabled_repos.get(id):
                not_enabled.append('%s, %s' % (
                    repo_info.get('description'), id)
                )
            # SLES 11 repo relative paths start with /repo, we have to
            # filter that out
            full_repo_path = '/var/lib/rmt/public/repo/' \
                + repo_info.get('location').strip('/').split('repo')[-1]
    
            if mirrored_repos.get(full_repo_path):
                del mirrored_repos[full_repo_path]
    
            if not os.path.exists(full_repo_path):
                missing_repo_dirs.append(full_repo_path)

    for id, repo_name in enabled_repos.items():
        if id not in configured_repo_ids:
            extra_enabled_repos.append(repo_name)
    extra_mirrored_repos = list(mirrored_repos.keys())

if not_enabled:
    print('Following expected repos are not enabled: "%s"' % str(not_enabled))
if missing_repo_dirs:
    print(
        'Following repo directories are missing: "%s"' % str(missing_repo_dirs)
    )
if extra_enabled_repos:
    print('Following enabled repos are extra: "%s"' % str(extra_enabled_repos))

if extra_mirrored_repos:
    print(
        'Following mirrored repos are extra: "%s"' % str(extra_mirrored_repos)
    )

if not_enabled or missing_repo_dirs or extra_enabled_repos \
        or extra_mirrored_repos:
    sys.exit(CRITICAL)
